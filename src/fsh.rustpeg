// Copyright (C) 2016  Sandeep Datta

use asg::{Expression, FunctionApplication, Primitive};
use std::path::PathBuf;

#[pub]
program -> Vec<Expression>
    = e1:(e0:expression EOL {e0})* e2:expression? EOF {
        let mut exprs = vec![];
        exprs.extend(e1);
        if let Some(e) = e2 {
            exprs.push(e);
        }
        exprs
    }

expression -> Expression
    = number / string / function

number -> Expression
    = integer

integer -> Expression
    = WS* d:digits WS* { 
        From::from(Primitive::Int(d.parse().unwrap()))
    }

digits -> &'input str
    = $([0-9]+)

string -> Expression
    = WS* "\"" xs:str_chars "\"" WS*  { 
        From::from(Primitive::Str(xs.to_string()))
    }

str_chars -> &'input str
    = $((!"\"" .)*)

function -> Expression
    = id:identifier maybe_args:function_args? {
        match maybe_args {
            Some(args) => Expression::Function(FunctionApplication {name: id.to_string(), args: args}),
            None => Expression::Function(FunctionApplication {name: id.to_string(), args: vec![]})
        }
    }

function_args -> Vec<Expression>
    = WS+ e:(integer / string / path)* { 
        e 
    }

identifier -> &'input str
    = $([_a-zA-Z][_a-zA-Z0-9]*)

path -> Expression
    = p: $(path_char+) {
        From::from(Primitive::Path(PathBuf::from(p.to_string())))
    }

path_char = !(WS/EOL) .

WS = [ \t]
EOL = [\n]
EOF = !.
