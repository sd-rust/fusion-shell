//Copyright (C) 2016  Sandeep Datta

use asg::{Expression, CommandApplication};

#[pub]
program -> Vec<Expression>
    = e1:(e0:expression EOL {e0})* e2:expression? EOF {
        let mut exprs = vec![];
        exprs.extend(e1);
        if let Some(e) = e2 {
            exprs.push(e);
        }
        exprs
    }

expression -> Expression
    = integer / string / command

integer -> Expression
    = WS* d:digits WS* { 
        Expression::Int(d.parse().unwrap()) 
    }

digits -> String
    = [0-9]+ { 
        match_str.to_string() 
    }

string -> Expression
    = WS* "\"" xs:str_chars "\"" WS*  { 
        Expression::Str(xs)
    }

str_chars -> String
    = (!"\"" .)* {
        match_str.to_string()
    }

command -> Expression
    = id:identifier maybe_args:command_args? {
        match maybe_args {
            Some(args) => Expression::Command(CommandApplication {name: id.to_string(), args: args}),
            None => Expression::Command(CommandApplication {name: id.to_string(), args: vec![]})
        }
    }

command_args -> Vec<Expression>
    = WS+ e:(integer / string / path)* { 
        e 
    }

identifier -> String
    = [_a-zA-Z][_a-zA-Z0-9]* { 
        match_str.to_string()
    }

path -> Expression
    = path_char+ {
        Expression::Str(match_str.to_string())
    }

path_char = !(WS/EOL) .

WS = [ \t]
EOL = [\n]
EOF = !.